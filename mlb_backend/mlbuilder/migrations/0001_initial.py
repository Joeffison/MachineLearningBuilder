# -*- coding: utf-8 -*-
# Generated by Django 1.11.8 on 2018-01-23 19:21
from __future__ import unicode_literals

from django.db import migrations, models
import django.db.models.deletion

decision_tree = {
    "description": "A decision tree is an algorithm that builds a flowchart like graph to illustrate the possible "
                   "outcomes of a decision. To build the tree, the algorithm first finds the variable that does the "
                   "best job of separating the data into two groups. "
                   "Then, it repeats the above step with the other variables. "
                   "This results in a tree graph, where each split represents a decision. "
                   "The algorithm chooses the splits such that the maximum number of observations are classified "
                   "correctly. The biggest advantage of a decision tree is that it is really intuitive and can be "
                   "understood even by people with no experience in the field.\n"
                   "https://www.r-bloggers.com/using-decision-trees-to-predict-infant-birth-weights/",
    "url": "https://www.r-bloggers.com/using-decision-trees-to-predict-infant-birth-weights/",
}

random_forest = {
    "description": "In Random Forests the idea is to decorrelate the several trees which are generated on the different"
                   " bootstrapped samples from training Data.And then we simply reduce the Variance in the Trees by "
                   "averaging them. Averaging the Trees helps us to reduce the variance and also improve the Perfomance"
                   " of Decision Trees on Test Set and eventually avoid Overfitting. The idea is to build lots of Trees"
                   " in such a way to make the Correlation between the Trees smaller.\n"
                   "https://www.r-bloggers.com/random-forests-in-r/",
    "url": "https://www.r-bloggers.com/random-forests-in-r/",
}

logistic_regression = {
    "description": 'Logistic regression is a method for fitting a regression curve, y = f(x), '
                   'when y is a categorical variable. The typical use of this model is '
                   'predicting y given a set of predictors x. The predictors can be continuous, categorical or a mix '
                   'of both. The categorical variable y, in general, can assume different values. '
                   'In the simplest case scenario y is binary meaning that it can assume either the value 1 or 0 '
                   '(“binomial logistic regression”), since the variable to predict is binary, however, '
                   'logistic regression can also be used to predict a dependent variable which can assume more '
                   'than 2 values (“multinomial logistic regression”).\n'
                   'https://www.r-bloggers.com/how-to-perform-a-logistic-regression-in-r/',
    "url": "https://www.r-bloggers.com/how-to-perform-a-logistic-regression-in-r/",
}

gaussian_naive_bayes = {
    "description": "Naive Bayes is a classification algorithm for binary (two-class) and multi-class "
                   "classification problems. It is called naive Bayes because the calculation of "
                   "the probabilities for each hypothesis are simplified to make their calculation tractable. "
                   "Rather than attempting to calculate the values of each attribute value P(d1, d2, d3|h), "
                   "they are assumed to be conditionally independent given the target value and calculated as "
                   "P(d1|h) * P(d2|H) and so on. This is a very strong assumption that is most unlikely in real data, "
                   "i.e. that the attributes do not interact. Nevertheless, the approach "
                   "performs surprisingly well on data where this assumption does not hold.\n"
                   "https://machinelearningmastery.com/naive-bayes-for-machine-learning/",
    "url": "https://machinelearningmastery.com/naive-bayes-for-machine-learning/",
}

APP_NAME = "mlbuilder"
implemented_algorithms = [
    ("Decision Tree", "from sklearn.tree import DecisionTreeClassifier", decision_tree),
    ("Random Forest", "from sklearn.ensemble import RandomForestClassifier", random_forest),
    ("Logistic Regression", "from sklearn.linear_model import LogisticRegression", logistic_regression),
    ("Gaussian Naive Bayes", "from sklearn.naive_bayes import GaussianNB", gaussian_naive_bayes)
]

def forwards_func(apps, schema_editor):
    # We get the model from the versioned app registry;
    # if we directly import it, it'll be the wrong version
    MLAlgorithm = apps.get_model(APP_NAME, "MLAlgorithm")
    db_alias = schema_editor.connection.alias
    MLAlgorithm.objects.using(db_alias).bulk_create([
        MLAlgorithm(name=algorithm[0], model_import=algorithm[1], reference_url=algorithm[2]["url"],
        reference_description=algorithm[2]["description"], enabled=True)
        for algorithm in implemented_algorithms
    ])

def reverse_func(apps, schema_editor):
    # forwards_func() creates two Country instances,
    # so reverse_func() should delete them.
    MLAlgorithm = apps.get_model(APP_NAME, "MLAlgorithm")
    db_alias = schema_editor.connection.alias
    MLAlgorithm.objects.using(db_alias).filter(name__in=[algorithm[0] for algorithm in implemented_algorithms]).delete()


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MLAlgorithm',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('enabled', models.BooleanField()),
                ('name', models.CharField(max_length=100)),
                ('model_import', models.CharField(max_length=100)),
                ('reference_url', models.CharField(max_length=100)),
                ('reference_description', models.CharField(max_length=100)),
            ],
            options={
                'ordering': ('created',),
            },
        ),
        migrations.CreateModel(
            name='MLModel',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('accuracy_score', models.FloatField()),
                ('model_file', models.CharField(max_length=100)),
                ('data_file', models.CharField(max_length=100)),
                ('predictors', models.CharField(max_length=10000)),
                ('targets', models.CharField(max_length=100)),
                ('algorithm', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to='mlbuilder.MLAlgorithm')),
            ],
            options={
                'ordering': ('created',),
            },
        ),
        migrations.RunPython(forwards_func, reverse_func),
    ]
